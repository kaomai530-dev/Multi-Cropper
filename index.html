// 黒帯自動カットの切り替え（無限ループを排除し、シンプルに1回だけ実行）
    autoRemoveCheckbox.addEventListener('change', (e) => {
        autoRemoveBlackBars = e.target.checked;
        if (!originalImage) return;

        // 座標とズームをリセット（基準を明確にする）
        zoomLevel = 1.0;
        imagePanX = 0;
        imagePanY = 0;

        if (autoRemoveBlackBars) {
            // 解析を実行（解析完了後に内部で cropImage が呼ばれます）
            detectAndRemoveBlackBars(originalImage, originalImage.originalFilename);
        } else {
            // チェック解除時：元画像に戻す
            currentImage = originalImage;
            processedImage = null;
            detectedCropBounds = null;
            
            updateImageTransform();
            setupCropSelector(currentImage);
            cropImage(currentImage);
        }
    });

    // 共通の表示倍率取得（プレビューと保存結果を一致させるための物差し）
    function getScale() {
        const container = document.getElementById('selector-container');
        if (!container || !originalImage) return 1;
        // originalImage.width を絶対基準にする
        return container.clientWidth / originalImage.width;
    }

    // 表示の更新（ズレをなくすため、常にこの計算を通す）
    function updateImageTransform() {
        if (!selectorImage) return;
        selectorImage.style.transform = `translate(${imagePanX}px, ${imagePanY}px) scale(${zoomLevel})`;
    }

    // クロップ処理（プレビューの黄色い枠と、保存結果を100%一致させる心臓部）
    function cropImage(img) {
        if (!selectorImage || !originalImage || !img) return;

        const scale = getScale();
        const rect = cropBox.getBoundingClientRect(); // 黄色い枠（プレビュー）
        const containerRect = document.getElementById('selector-container').getBoundingClientRect();

        // プレビュー上の枠の座標を、実際の画像のピクセル座標へ正確に逆算
        // 表示倍率(scale)とズーム(zoomLevel)の両方を考慮
        const cropX = (rect.left - containerRect.left - imagePanX + (originalImage.width * scale / 2) * (1 - zoomLevel)) / (scale * zoomLevel);
        const cropY = (rect.top - containerRect.top - imagePanY + (originalImage.height * scale / 2) * (1 - zoomLevel)) / (scale * zoomLevel);
        const cropW = rect.width / (scale * zoomLevel);
        const cropH = rect.height / (scale * zoomLevel);

        const croppedCanvas = document.createElement('canvas');
        croppedCanvas.width = cropW;
        croppedCanvas.height = cropH;
        const ctx = croppedCanvas.getContext('2d');

        // 補完品質を最大に設定
        ctx.imageSmoothingEnabled = true;
        ctx.imageSmoothingQuality = 'high';

        // 常に「元画像」から計算した座標で切り抜く（これが一番正確）
        ctx.drawImage(originalImage, cropX, cropY, cropW, cropH, 0, 0, cropW, cropH);

        const croppedImgDisplay = document.getElementById('cropped-img');
        if (croppedImgDisplay) {
            croppedImgDisplay.src = croppedCanvas.toDataURL('image/png');
        }
    }

    // 黒帯検出とカット（連打バグが起きないよう整理）
    function detectAndRemoveBlackBars(img, originalFilename) {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = img.width;
        canvas.height = img.height;
        ctx.drawImage(img, 0, 0);
        
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;
        const threshold = 15;
        const minBlackRatio = 0.95;

        function isRowBlack(y) {
            let blackCount = 0;
            for (let x = 0; x < canvas.width; x += 3) {
                const i = (y * canvas.width + x) * 4;
                if (data[i] <= threshold && data[i + 1] <= threshold && data[i + 2] <= threshold) blackCount++;
            }
            return (blackCount / (canvas.width / 3)) >= minBlackRatio;
        }

        let top = 0;
        for (let y = 0; y < canvas.height * 0.4; y++) {
            if (!isRowBlack(y)) { top = y; break; }
        }

        let bottom = canvas.height;
        for (let y = canvas.height - 1; y >= canvas.height * 0.6; y--) {
            if (!isRowBlack(y)) { bottom = y + 1; break; }
        }

        const croppedHeight = bottom - top;
        const resultCanvas = document.createElement('canvas');
        resultCanvas.width = canvas.width;
        resultCanvas.height = croppedHeight;
        const resultCtx =
